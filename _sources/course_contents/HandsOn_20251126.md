# Docker Hands-on training (26-11-2025)

## Initial considerations
In this course, you can work on your laptop if you have installed the Docker in your machine. For local installation:

- Mac: <https://docs.docker.com/desktop/setup/install/mac-install/>
- Linux: <https://docs.docker.com/engine/install/>
- Windows: <https://docs.docker.com/desktop/setup/install/windows-install/>

Clone the repository that contain the data, script and all the course information
```
git clone git@github.com:biosustain/dsp_docker_training.git
```

Alternatively use Github Codespaces to avoid any system incompatibility. You can open directly a GitHub codespace for this specific repository here: [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/biosustain/dsp_docker_training) 

## Data and biological context
 Link to Sebastian slides

## Running a container

Once the docker daemon is running you can run containers, we will start with the `hello-world` container, which is hosted on [Docker Hub](https://hub.docker.com/).

In your command line, run the publicly available `hello-world` container:

```
docker run hello-world
```
We usually run that to check that our installation is working correctly. If you read `'Hello from Docker!'` everything is fine for now.

Please read the information given. Docker first tried to check if we had the container locally, as we did not, the online container repositories were checked. As the container was found, it was donwloaded, and run.

## Pulling a container

Pull the publicly available `debian:bookworm-slim` container and verify it has been downloaded. Images are pulled by default from Docker hub.

```
docker pull debian:bookworm-slim
```

To check which images you have pulled, you can use `images` command with the following syntax:
```
docker images
``` 

## Writing our Dockerfile

Docker images are created from a textfile called `Dockerfile`. 

This text file contains list of commands to assemble and configure the image with the software required.

For our dockerfile, we will learn the following instructions: `FROM`, `LABEL`, `WORKDIR`, `RUN`, `COPY` and `ENV`
Go to [Dockerfile references](https://docs.docker.com/reference/dockerfile/) and find out what are these instructions for.

First thing we need is a base image. A dockerfile can use an existing image, and build on top of it. A base image is an image you designate in a `FROM` directive in a Dockerfile. A Dockerfile with the `FROM scratch` directive uses an empty base image. When we build the Docker image from `debian:13` we will get an image with something really close to haveing installed debian distribution (version 13). 

What do we need to add to our Dockerfile?
- Base image
- Working directory
- Instructions to download and install software and place it on the executables path
    - curl to download feature counts
    - bowtie2: align reads to a reference
    - feature counts: count reads
    - samtools: deal with .bam files (sort and index them)
- copy an script example

Open a file called Dockerfile. ```code Dockerfile```

First let's specify which base image we want to use. We are going to use one of the latest Debian versions as base image:
```{code-block} docker
FROM debian:13
```

Define the working directory
```{code-block} docker
WORKDIR /app
```

Next, we are going to update the downloader manager `apt-get` and installing the software that we need and can be found in apt-get (easier solution). In our case we need curl (downloading feature counts), bowtie2 (the aligner) and samtools (sort and index bam files).
We need to use `RUN` to execute building commands.
```{code-block} docker
RUN apt-get update && apt-get -y install \
    bowtie2 \
    curl \
    samtools
``` 

However, not all tools needed can be installed with `apt-get`, for example in our case we need to download feature counts from a particular URL. This process is a bit more involved. We need to:
- download it using curl
- uncompress it
- removing the executable
- specify in which path there is the executable

```{code-block} docker
# Download feature counts (package called subread)
RUN curl -L -o subread-2.0.8-Linux-x86_64.tar.gz https://sourceforge.net/projects/subread/files/subread-2.0.8/subread-2.0.8-Linux-x86_64.tar.gz/download

# Uncompress and remove the executable
RUN tar -xzf subread-2.0.8-Linux-x86_64.tar.gz && \
    rm subread-2.0.8-Linux-x86_64.tar.gz
```

Specify the path to the feature counts executable
```{code-block} docker
# Specify the path to the executable
ENV PATH="${PATH}:/app/subread-2.0.8-Linux-x86_64/bin/"
```

Finally we are going to copy to the image the scripts folder that contains the script that we are going to run.
```{code-block} docker
COPY scripts/ ./scripts/
```

## Building an image from ther Dockerfile

When you have a Dockerfile, you can build it to a docker image with the `build` command using the following syntax:
`docker build --tag <my-image-name:my-optional-image-tag> <my-location-path>`, where `--tag` is equivalent to `-t`, `-f` specifies the Dockerfile, and last thing is `<my-location-path>` that can be referenced with `.`

Let's build your Dockerfile to an image:

```{code-block} bash
docker build -t align_count -f docker_file/Dockerfile .
```

## Running an container in interactive mode

While we would rather reccomend using _virtual environments_ for running specific environments interactively, it can be handy to be familiar with docker's ability to run a container in interactive mode. This is just useful to check if the expected software is present within a container, but we do not recommend to change anything in the container, instead do it in the Dockerfile.

This is done by adding the two command line inputs to the `docker run` command: `--interactive` and `--tty`,  which have the equivalents `-i` and `-t`. 

They can thus be run with the following syntax: `docker run -it <container-name> <command>`

We will launch the BASH shell (`bash`) in the `align_count` image:
```{code-block} bash
docker run -it align_count bash
```
Then you can check what is in there `ls -la` or in which directory are we `pwd`. Which folder can you see?

After looking around lets exit the bash with `exit`.

Check which software versions you included in your Docker image:
```{code-block} bash
docker run align_count bowtie2 --version
docker run align_count featureCounts -v
```

We know that our images are locally available. We also want to check if our containers are still existing.

To do this try: `docker ps -a` 

When we do this we can see that they are still existing. There is no reason for this as these containers are supposed to just do one job based on the docker image.

We can keep our space tidy by adding `--rm` to the run command to make sure the container is wiped after usage.

## File system mounts

Containers are isolated and run in a completely separate file system and it cannot access the hosting file system by default.

We can use the `--volume <host-directory>:<container-directory>` syntax to make a file or a folder available inside our container. `-v` is equivalent to `--volume`. Its argument consists of two fields separated by a colon (`:`):

- Host source directory path
- Container target directory path


## Running the image mounting the data

Finally we are going to build our command line to run our script to align and count inside the Docker image.

We will now make two mounted volumes, a read-only for data (ro), and a writable for results

Mount paths must be absolute.

```{code-block} bash
docker run --rm -v ./data/:/app/data:ro -v ./results/:/app/results align_count ./scripts/align_and_count_prok.sh
```
## Results files and interpretion

Results have been copied back from the container to my local ```results``` folder (host). Let's have a look.  

In total, four output files are generated:  

- Running ```bowtie2```/```samtools``` generates the sorted alignment file ```aligned_sorted.bam``` and the bam alignment index ```aligned_sorted.bam.bai``` (this index is used to accelerate read counting by featureCounts).  
- Running ```featureCounts```generates the ```gene_counts.txt``` which holds unnormalised read count data per gene along with additional information like gene length, strand etc. 
    - Out of 4305 genes, 2720 genes have a read count of at least 1; the remaining genes have zero counts.
- The ```gene_counts.txt.summary```file details count statistics. 
    - It shows that 39913 reads were assigned a genomic feature (gene) and counted. 
    - Reads that could not be assigned a genomic feature amounted to 3830 and 1840 reads were ambigious (aligned to more than one genomic feature).